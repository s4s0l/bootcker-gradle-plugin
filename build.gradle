//based on https://github.com/avast/docker-compose-gradle-plugin/build.gradle

buildscript {
    repositories {
        jcenter()
        maven { url 'https://plugins.gradle.org/m2/' }
    }
    dependencies {
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
        classpath 'com.gradle.publish:plugin-publish-plugin:0.9.6'
    }
}

apply plugin: 'com.jfrog.bintray'
apply plugin: 'groovy'
apply plugin: 'java'
apply plugin: 'com.gradle.plugin-publish'

/************************************************************************************
 * METADATA
 */
group = 'org.s4s0l.gradle'
archivesBaseName = 'bootcker-gradle-plugin'
version = version == 'unspecified' ? 'DEVELOPER-SNAPSHOT' : version
description = "Gradle plugin for running spring boot based micro services with docker compose during gradle build."
ext {
    vcsUrl = "https://github.com/s4s0l/bootcker-gradle-plugin.git"
    websiteUrl = "https://github.com/s4s0l/bootcker-gradle-plugin"
    issueTrackerUrl = "https://github.com/s4s0l/bootcker-gradle-plugin/issues"
    license = "Apache-2.0"
    displayName = "Gradle Spring Boot Docker Compose Plugin"
    organization = "sasol-oss"
    projectId = "${group}.${archivesBaseName}"
    githubRepository = "s4s0l/bootcker-gradle-plugin"
}
/**
 ***********************************************************************************/




sourceCompatibility = '1.8'
targetCompatibility = '1.8'

repositories {
    jcenter()
    maven {
        url "https://plugins.gradle.org/m2/"
    }
}

dependencies {
    compile gradleApi()
    compile "org.yaml:snakeyaml:1.16"
    compile 'com.avast.gradle:docker-compose-gradle-plugin:0.3.15'
    compile 'commons-io:commons-io:2.3'
    testCompile gradleTestKit()
    testCompile "io.spring.gradle:dependency-management-plugin:0.6.0.RELEASE"
    testCompile "org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE"
    testCompile "se.transmode.gradle:gradle-docker:1.2"
    testCompile "io.franzbecker:gradle-lombok:1.7"
    testCompile('org.spockframework:spock-core:1.0-groovy-2.4') {
        // Conflicting module versions: 2.4.4 vs. 2.4.1
        exclude group: 'org.codehaus.groovy'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '3.2.1'
}

/************************************************************************************
 * Packaging section
 */
task sourcesJar(type: Jar) {
    classifier 'sources'
    from sourceSets.main.allSource
}
task javadocJar(type: Jar, dependsOn: [groovydoc]) {
    classifier 'javadoc'
    from groovydoc.destinationDir
}
tasks.withType(Jar) {
    manifest {
        attributes(
                "Manifest-Version": "1.0",
                "Gradle-Version": "${gradle.gradleVersion}",
                "Extension-Name": "${archivesBaseName}",
                "Build-Jdk": "${JavaVersion.current().toString()}",
                "Url": "${websiteUrl}",
                "Name": "${projectId}".replaceAll("\\.", "/"),
                "Specification-Title": "${displayName}",
                "Specification-Vendor": "${organization}",
                "Specification-Version": "${version}",
                "Implementation-Vendor": "${organization}",
                "Implementation-Title": "${group}.${archivesBaseName}",
                "Implementation-Version": "${version}",
                "License": "${license}",
        )
    }
    from("LICENSE") {
        into "META-INF"
    }
}
artifacts {
    archives sourcesJar
    archives javadocJar
}
/**
 ***********************************************************************************/

/************************************************************************************
 * Publication stuff
 */
bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    configurations = ['archives']
    publish = true
    pkg {
        repo = 'maven'
        name = "${project.archivesBaseName}"
        desc = "project.description"
        userOrg = "${project.organization}"
        licenses = ["${project.license}"]
        vcsUrl = "${project.vcsUrl}"
        websiteUrl = "${project.websiteUrl}"
        issueTrackerUrl = "${project.issueTrackerUrl}"
        githubRepo = "${project.githubRepository}" //Optional Github repository
        githubReleaseNotesFile = 'README.md'
        labels = ['docker', 'docker-compose', 'gradle', 'spring-boot', 'boot']
        version {
            name = project.version
            vcsTag = project.version
        }
    }
}

project.ext.set('gradle.publish.key', System.getenv('GRADLE_PORTAL_KEY'))
project.ext.set('gradle.publish.secret', System.getenv('GRADLE_PORTAL_SECRET'))
pluginBundle {
    website = "${project.websiteUrl}"
    vcsUrl = "${project.vcsUrl}"
    description = "${project.description}"
    tags = ['docker', 'docker-compose', 'gradle', 'spring-boot', 'boot']
    plugins {
        dockerComposePlugin {
            id = "${project.projectId}"
            displayName = "${project.displayName}"
        }
    }
}
/**
 ***********************************************************************************/

/************************************************************************************
 * Settings needed for GradlePluginFunctionalSpecification based tests
 * TODO move it with above classes to separate plugin for writing plugins
 */
apply plugin: 'maven'
ext.localRepoUrl = new File(rootProject.buildDir, 'localrepo')
plugins.withType(MavenPlugin) {
    install {
        repositories {
            mavenDeployer {
                repository(url: localRepoUrl.toURI())
            }
        }
    }
}
tasks.withType(Test) {
    environment "GRADLE_USER_HOME", gradle.gradleUserHomeDir
    environment "PROJECT_VERSION", project.version
    environment "LOCAL_REPO", localRepoUrl.absolutePath
    environment "LOCAL_BUILD_DIR", rootProject.buildDir.absolutePath
    dependsOn install
    testLogging {
        exceptionFormat 'full'
    }
}
/**
 ***********************************************************************************/
